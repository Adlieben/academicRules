% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/tune_rules.R
\name{tune_rules}
\alias{tune_rules}
\title{Tune multiple numeric rules to approach a desired pass rate}
\usage{
tune_rules(
  data,
  ruleset,
  candidates,
  target_rate,
  outcome_col_name = "TUNED_OUTCOME"
)
}
\arguments{
\item{data}{A data frame or tibble that will be classified.}

\item{ruleset}{An object of class "academic_ruleset".}

\item{candidates}{A named list of vectors. Each name corresponds to a rule in \code{ruleset},
and the vector is the candidate values to try for \code{rule$value}. For example:
\code{list(min_total=20:30, max_fails=0:3)}.
\itemize{
\item Each rule must be of type "minimum" or "maximum" (i.e., numeric).
\item If you include a "logical" rule in \code{candidates}, that won't work
unless it also has a numeric field, which is rare.
}}

\item{target_rate}{A numeric between 0 and 1, the desired pass rate.}

\item{outcome_col_name}{Name of the outcome column in the classified data. Defaults to "TUNED_OUTCOME".}
}
\value{
A list with components:
\describe{
\item{\code{best_params}}{A named vector of the numeric values for each rule that yields
a pass rate closest to \code{target_rate}.}
\item{\code{best_rate}}{The pass rate at that combination.}
\item{\code{results}}{A data frame with one row per combination, containing the pass rate
and the parameter values.}
}
}
\description{
Performs a grid search over multiple rules, each of which may have a vector of candidate
numeric values. For each combination, it applies the updated ruleset, computes the pass rate,
and identifies which combination yields a pass rate closest to the user-specified target.
}
\examples{
\dontrun{
# Suppose we have a rule 'min_total' (minimum) that must be >=24
# and a rule 'max_2s' (maximum) that must be <=2
my_rules <- define_rule_set(list(
  min_total = list(type="minimum", value=24, dimension="Total"),
  max_2s    = list(type="maximum", value=2, dimension="count_2")
))

# We'll try min_total in [20, 22, 24, 26, 28] and max_2s in [1,2,3]
# aiming for a pass rate near 0.70
multi_res <- tune_rules(
  data = dummy_ib_data,
  ruleset = my_rules,
  candidates = list(min_total = seq(20, 28, 2),
                    max_2s    = 1:3),
  target_rate = 0.70
)
multi_res$best_params
multi_res$best_rate
head(multi_res$results)
}
}
